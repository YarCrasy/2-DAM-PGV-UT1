import java.io.File;
import java.io.IOException;
import java.util.Collections;
import java.util.List;
import java.util.ArrayList;
import java.util.Stack;

/**
 * Parent process controller.
 *
 * <p>This class is responsible for discovering input files in the `./datos/` directory,
 * spawning a child Java process for each file to perform per-file processing, waiting
 * for those processes to finish, and aggregating results produced by children.
 * Aggregation is done by reading result files written under `Utils.savePath`.
 *
 * <p>It collects per-file summaries (words and void lines), computes totals for words
 * and vowels across all result files, calculates the average vowels per word, and
 * saves a parent summary file.
 */
public class Parent
{
    final static String dir = "./datos/";
    public List<File> files = new ArrayList<>();
    Process[] childProcess;
    final List <String> resultSummary = new ArrayList<>();

    int vowelTotal = 0;
    int wordsTotal = 0;


    /**
     * Orchestrates the overall processing lifecycle.
     *
     * <p>Creates a Parent instance, loads input files, starts child processes,
     * waits for them to finish and then processes results.
     *
     * <p>Note: this method uses a non-standard signature (no String[] args).
     */
    static void main() {
        Parent p = new Parent();
        p.loadFiles();
        p.processFiles();
        p.waitProcesses();
        p.processResults();
    }

    /**
     * Loads all files from the configured input directory into the `files` list.
     * If the directory is empty or cannot be read, writes an error to stderr.
     */
    void loadFiles()
    {
        File folder = new File(dir);
        File[] listOfFiles = folder.listFiles();
        if (listOfFiles == null) {
            System.err.println("No files loaded from directory: " + dir);
            return;
        }
        Collections.addAll(files, listOfFiles);
    }

    /**
     * Starts a child Java process for each file found in `files`.
     *
     * <p>For each file it also appends a per-file word/void-line summary using
     * `Utils.countWordsInFile(File)`. Child processes are started with the same
     * classpath as the parent and run the `Child` main class passing the file path.
     */
    void processFiles()
    {
        childProcess = new Process[files.size()];
        String cp = System.getProperty("java.class.path");
        int i = 0;
        for (File file : files) {
            resultSummary.add(Utils.countWordsInFile(file));
            ProcessBuilder pb = new ProcessBuilder("java", "-cp", cp, "Child", file.getPath());
            pb.inheritIO();

            try {
                childProcess[i++] = pb.start();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }

    /**
     * Blocks until all started child processes have terminated.
     * Converts InterruptedException into an unchecked RuntimeException.
     */
    void waitProcesses()
    {
        for (Process process : childProcess) {
            try {
                process.waitFor();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }

    /**
     * Aggregates results generated by child processes, computes averages and
     * writes a final parent summary using `Utils.saveFile`.
     */
    void processResults()
    {
        Stack<Thread> threads = new Stack<>();
        startCountingThreads(threads);
        waitCountingThreads(threads);

        float aux = (wordsTotal == 0) ? 0 : (float)vowelTotal / wordsTotal;
        resultSummary.add("Promedio de vocales por palabra: " + aux);

        Utils.saveFile("parent", resultSummary);
    }

    /**
     * Create and start background threads that compute totals from result folders.
     *
     * @param threads stack to which started threads will be pushed
     */
    void startCountingThreads(Stack<Thread> threads) {
        File[] resultFolders = getResultFolders();
        if (resultFolders.length == 0) {
            System.err.println("No result folders found.");
            return;
        }
        for (File folder : resultFolders) {
            String path = folder.getPath();
            if (path.equals(".\\resultados\\minusculas")) {
                threads.push(new Thread(countTotalWords(folder))).start();
            }
            else if (path.equals(".\\resultados\\vocales")) {
                threads.push(new Thread(countTotalVowels(folder))).start();
            }
        }
    }

    /**
     * Waits for all threads pushed into the provided stack to finish.
     *
     * @param threads stack containing threads to join
     */
    void waitCountingThreads(Stack<Thread> threads) {
        while (!threads.isEmpty()) {
            try {
                threads.pop().join();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }

    /**
     * Returns the list of files/folders under the global results directory.
     *
     * @return array of File objects contained in `Utils.savePath`; empty array if none
     */
    File[] getResultFolders() {
        File resFolder = new File(Utils.savePath);
        File[] resultFiles = resFolder.listFiles();
        if (resultFiles == null) {
            System.err.println("No result folders found in directory getResultFolders(): " + Utils.savePath);
            return new File[0];
        }
        return resultFiles;
    }

    /**
     * Builds a Runnable that reads all files in the provided folder and accumulates
     * the total word count into the parent instance field `wordsTotal`.
     *
     * @param folder folder that contains per-file word results (expected under minusculas)
     * @return Runnable which will perform the counting when executed
     */
    Runnable countTotalWords(File folder) {
        return () -> {
            File[] resultFiles = getFilesInFolder(folder);
            for (File f : resultFiles) {
                String[] lines = Utils.loadFile(f);
                assert lines != null;
                for (String line : lines) {
                    wordsTotal += line.split("\\s+").length;
                }
            }
            resultSummary.add("Total words: " + wordsTotal);
        };
    }

    /**
     * Builds a Runnable that reads all files in the provided folder and accumulates
     * the total vowel count into the parent instance field `vowelTotal`.
     *
     * @param folder folder that contains per-line vowel counts (expected under vocales)
     * @return Runnable which will perform the counting when executed
     */
    Runnable countTotalVowels(File folder) {
        return () -> {
            File[] resultFiles = getFilesInFolder(folder);
            for (File f : resultFiles) {
                String[] lines = Utils.loadFile(f);
                assert lines != null;
                for (String line : lines) {
                    vowelTotal += Integer.parseInt(line);
                }
            }
            resultSummary.add("Total vowels: " + vowelTotal);
        };
    }

    /**
     * Returns an array of files inside the provided folder. If the folder cannot
     * be read an empty array is returned and an error is logged to stderr.
     *
     * @param folder folder to list
     * @return array of files contained in folder or empty array when not accessible
     */
    File[] getFilesInFolder(File folder) {
        File[] listOfFiles = folder.listFiles();
        if (listOfFiles == null) {
            System.err.println("No files found in directory getFilesInFolder(): " + folder.getPath());
            return new File[0];
        }
        else return listOfFiles;
    }

}